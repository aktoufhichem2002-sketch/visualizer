<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Visualiseur • Barres centrées + miroir</title>
<style>
  html, body {
    margin: 0;
    background: #0b0b0b; /* fond sombre élégant */
    height: 100%;
    overflow: hidden;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  }
  /* Conteneur pour centrer la zone de visualisation */
  .wrap {
    position: fixed;
    inset: 0;
    display: grid;
    place-items: center; /* centre au milieu de l’écran */
  }
  /* Zone compactée (tu peux ajuster la taille ici) */
  .box {
    position: relative;
    width: min(900px, 90vw);   /* largeur max 900px */
    height: 280px;             /* hauteur compacte */
  }
  #canvas {
    position: absolute;
    inset: 0;
  }

  /* Bouton simple pour charger l’audio */
  .file {
    position: fixed;
    top: 16px;
    left: 16px;
    padding: 8px 12px;
    background: #ffffff22;
    color: #eee;
    border-radius: 8px;
    cursor: pointer;
    z-index: 10;
  }
  .file input { display: none; }
</style>
</head>
<body>

<label class="file">
  Charger un audio
  <input id="audioFile" type="file" accept="audio/*">
</label>

<div class="wrap">
  <div class="box">
    <canvas id="canvas"></canvas>
  </div>
</div>

<script>
/* -----------------------------
   Réglages faciles à modifier
------------------------------*/
const SETTINGS = {
  bars: 64,              // nombre de barres
  gap: 0.25,             // 0..1 -> 0 = barres collées, 0.25 = 25% d’espace
  mirror: true,          // effet miroir vertical (haut + bas)
  heightFactor: 0.9,     // amplitude max relative à la moitié de la box
  fftSize: 512,          // 256/512/1024
  smoothing: 0.85,       // lissage visuel (0..1)
  // Couleurs: dégradé du bas vers le haut (et symétrique)
  colors: ["#e43f5a", "#ffa62b", "#ffd166"] // rouge -> orange -> doré
};

const fileInput = document.getElementById("audioFile");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const box = document.querySelector(".box");

let audioCtx, analyser, data;

// Adapter le canvas à la taille de .box
function resize() {
  const { width, height } = box.getBoundingClientRect();
  canvas.width = Math.floor(width);
  canvas.height = Math.floor(height);
}
resize();
addEventListener("resize", resize);

// Crée un dégradé vertical pour les barres
function makeGradient() {
  const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
  // on répartit les couleurs sur 0..1
  for (let i = 0; i < SETTINGS.colors.length; i++) {
    const t = i / (SETTINGS.colors.length - 1);
    g.addColorStop(t, SETTINGS.colors[i]);
  }
  return g;
}

let barFill = null;

// Dessin principal (barres centrées + miroir)
function drawBars() {
  requestAnimationFrame(drawBars);
  if (!analyser) return;

  analyser.getByteFrequencyData(data);

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!barFill) barFill = makeGradient();
  ctx.fillStyle = barFill;

  const N = SETTINGS.bars;
  const spacing = canvas.width / N; // largeur “pas”
  // largeur réelle de la barre (selon gap)
  const barWidth = spacing * (1 - SETTINGS.gap);

  // hauteur max par demi-zone (car miroir)
  const halfH = (canvas.height / 2) * SETTINGS.heightFactor;

  for (let i = 0; i < N; i++) {
    // on échantillonne le spectre (si data < N, on projette)
    const idx = Math.floor(i * (data.length / N));
    const value = data[idx] || 0;
    const percent = value / 255;
    const h = percent * halfH;

    const x = i * spacing + (spacing - barWidth) / 2;
    const midY = canvas.height / 2;

    if (SETTINGS.mirror) {
      // barre vers le haut (miroir)
      ctx.fillRect(x, midY - h, barWidth, h);
      // barre vers le bas (miroir)
      ctx.fillRect(x, midY, barWidth, h);
    } else {
      // sans miroir: uniquement vers le haut
      ctx.fillRect(x, midY - h, barWidth, h);
    }
  }
}

// Chargement audio
fileInput.addEventListener("change", async () => {
  const file = fileInput.files[0];
  if (!file) return;

  // Création graphe audio
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = SETTINGS.fftSize;
  analyser.smoothingTimeConstant = SETTINGS.smoothing;
  data = new Uint8Array(analyser.frequencyBinCount);

  const audio = new Audio(URL.createObjectURL(file));
  audio.crossOrigin = "anonymous";
  audio.loop = true;

  // Démarrage audio (autoplay peut demander un clic)
  try { await audio.play(); }
  catch { 
    alert("Clique une fois sur la page puis recharge le fichier audio.");
    return;
  }

  const src = audioCtx.createMediaElementSource(audio);
  src.connect(analyser);
  analyser.connect(audioCtx.destination);

  // Recréer le dégradé si la taille change
  barFill = makeGradient();

  drawBars();
});
</script>
</body>
</html>
